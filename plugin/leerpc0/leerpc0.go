package leerpc0

import (
	"fmt"
	"strings"

	"github.com/encircles/protoc-gen-leerpc0/generator"

	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
)

// Paths for packages used by code generated in this file,
// relative to the import_prefix of the generator.Generator.
const (
	leerpc0ServerPkgPath      = "github.com/encircles/leerpc0"
	leerpc0ClientPkgPath      = "github.com/encircles/leerpc0/client"
	leerpc0InterceptorPkgPath = "github.com/encircles/leerpc0/interceptor"
)

func init() {
	generator.RegisterPlugin(new(leerpc0))
}

type leerpc0 struct {
	gen *generator.Generator
}

//Name returns the name of this plugin
func (p *leerpc0) Name() string {
	return "leerpc0"
}

//Init initializes the plugin.
func (p *leerpc0) Init(gen *generator.Generator) {
	p.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (p *leerpc0) objectNamed(name string) generator.Object {
	p.gen.RecordTypeUse(name)
	return p.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (p *leerpc0) typeName(str string) string {
	return p.gen.TypeName(p.objectNamed(str))
}

// GenerateImports generates the import declaration for this file.
func (p *leerpc0) GenerateImports(file *generator.FileDescriptor) {
}

// P forwards to g.gen.P.
func (p *leerpc0) P(args ...interface{}) { p.gen.P(args...) }

// Generate generates code for the services in the given file.
func (p *leerpc0) Generate(file *generator.FileDescriptor) {

	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	_ = p.gen.AddImport(leerpc0ServerPkgPath)
	_ = p.gen.AddImport(leerpc0ClientPkgPath)
	_ = p.gen.AddImport(leerpc0InterceptorPkgPath)
	_ = p.gen.AddImport("context")

	// generate all services
	for i, service := range file.FileDescriptorProto.Service {
		p.generateService(file, service, i)
	}
}

// generateService generates all the code for the named service
func (p *leerpc0) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	originServiceName := service.GetName()
	serviceName := upperFirstLatter(originServiceName)
	p.P("// This following code was generated by protoc-gen-leerpc0, DO NOT EDIT!!!")
	p.P()
	p.P("//================== server skeleton ===================")
	p.P(fmt.Sprintf(`type %sService interface {
				`, serviceName))

	for _, method := range service.Method {
		p.generateServerInterfaceCode(method)
	}
	p.P("}")

	p.generateServiceDesc(service, file.GetPackage())
	for _, method := range service.Method {
		p.generateServerCode(service, method, file.GetPackage())
	}
	p.generateRegisterCode(service)

	p.P("//================== client stub===================")
	p.P(fmt.Sprintf(`//%sClientProxy is a client proxy for service %s.
		type %sClientProxy interface {
	`, serviceName, serviceName, serviceName))
	for _, method := range service.Method {
		p.generateClientInterfaceCode(method)
	}
	p.P("}")
	p.P(fmt.Sprintf(`
		type %sClientProxyImpl struct {
			client client.Client
			opts   []client.Option
		}
	`, serviceName))
	p.P(fmt.Sprintf(`
		func New%sClientProxy(opts ...client.Option) %sClientProxy {
			return &%sClientProxyImpl{client: client.DefaultClient, opts: opts}
		}
	`, serviceName, serviceName, serviceName))

	for _, method := range service.Method {
		p.generateClientCode(service, method, file.GetPackage())
	}
}

func (p *leerpc0) generateRegisterCode(service *pb.ServiceDescriptorProto) {
	serviceName := upperFirstLatter(service.GetName())
	p.P(fmt.Sprintf(`
		func RegisterService(s *leerpc0.Server, svr interface{}) {
			s.Register(_%s_serviceDesc, svr)
		}
	`, serviceName))
}

func (p *leerpc0) generateServiceDesc(service *pb.ServiceDescriptorProto, pkgPath string) {

	serviceName := upperFirstLatter(service.GetName())
	p.P(fmt.Sprintf(`var _%s_serviceDesc = &leerpc0.ServiceDesc {
		ServiceName: "%s.%s",
		HandlerType: (*%sService)(nil),
		Methods: []*leerpc0.MethodDesc {
	`, serviceName, pkgPath, serviceName, serviceName))

	for _, method := range service.Method {
		methodName := upperFirstLatter(method.GetName())
		p.P(fmt.Sprintf(`{
			MethodName: "%s",
			Handler: %sService_%s_Handler,
		},`, methodName, serviceName, methodName))
	}

	p.P("},")
	p.P("}")
}

func (p *leerpc0) generateServerInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s)(*%s, error)",
		methodName, inType, outType))
}

func (p *leerpc0) generateServerCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	p.P(fmt.Sprintf(`
		func %sService_%s_Handler(ctx context.Context, svr interface{}, dec func(interface{}) error,ceps []interceptor.ServerInterceptor)(interface{},error){
			
			req := new(%s)
			if err := dec(req); err != nil {
				return nil, err	
			}

			if len(ceps) == 0 {
				return svr.(%sService).%s(ctx, req)
			}
			
			handler := func(ctx context.Context, reqbody interface{})(interface{}, error) {
				return svr.(%sService).%s(ctx, reqbody.(*%s))
			}
				
			return interceptor.ServerIntercept(ctx, req, ceps, handler)
		}
	`, serviceName, methodName, inType, serviceName, methodName, serviceName, methodName, inType))
}

func (p *leerpc0) generateClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto, pkgName string) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`// %s is server rpc method as defined
		func (c *%sClientProxyImpl) %s(ctx context.Context, req *%s, opts ...client.Option) (*%s ,error){
			
			callopts := make([]client.Option, 0, len(c.opts)+len(opts))
			callopts = append(callopts, c.opts...)
			callopts = append(callopts, opts...)

			rsp := &%s{}
			err := c.client.Invoke(ctx, req, rsp, "/%s.%s/%s", callopts...)
			if err != nil {
				return nil, err
			}

			return rsp, nil
		}
	`, methodName, serviceName, methodName, inType, outType, outType, pkgName, serviceName, methodName))
}

func (p *leerpc0) generateClientInterfaceCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf("%s(ctx context.Context, req *%s, opts ...client.Option)(*%s, error)",
		methodName, inType, outType))
}

// upperFirstLatter make the fisrt charater of given string  upper class
func upperFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
